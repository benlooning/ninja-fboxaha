var util = require('util')
  ,EventEmitter = require('events').EventEmitter
  ,http = require('http')
  ,xml2js = require('xml2js')
  ,crypto = require('crypto')
  ,iconvlite = require('iconv-lite')
  ,cheerio = require('cheerio');  
  
module.exports = Fbox;
util.inherits(Fbox,EventEmitter);

function Fbox(box) {
  var self = this;
  EventEmitter.call(this);
  if (!box) throw new Error("host name is missing")
  this._box = box;
  this.boxInfo = { fritz: null, type: null, version: null, serial: null, os: {major: null, minor: null} };
  this.SID = null;
  this.ahaDevices  = [];
  this.ahaDeviceIDs  = [];
  this.blockSID = false;
  this.blockSIDchanched = new EventEmitter();
};

// session handling

Fbox.prototype.renewSID = function(cb) {
  var self = this;
  
  if (self.blockSID == false) { //block renew proccess for other devices
	self.blockSID = true;
    self.createSession (null, function (error, info) {
	  if (error == null) {
	    self.blockSID = false;
		self.blockSIDchanched.emit('done', null);
	    cb (null, info);
	  } else {
	    self.blockSID = false;
		self.blockSIDchanched.emit('done', error);
	    cb (error, info);
	  }
    });
  } else { //wait for another device to renew SID
    self.blockSIDchanched.once('done', function(error) {
	  cb (error, null);
	});
  }
};

Fbox.prototype.validateBox = function(cb) {
  var self = this;
  var os = { major: '', minor: '' };
  requestValueAction (this._box.host, '/jason_boxinfo.xml', function (error, info) {

	if(error)
	  return cb(error, null);

	try {
	  if (info['j:BoxInfo']){
		self.boxInfo.type = info['j:BoxInfo']['j:Name'].toString();
		self.boxInfo.version = info['j:BoxInfo']['j:Version'].toString();
		self.boxInfo.serial = info['j:BoxInfo']['j:Serial'].toString();
		self.boxInfo.fritz = true;
		if (self.boxInfo.version != null) {
			self.boxInfo.os.major = parseInt(self.boxInfo.version.split('.')[1]);
			self.boxInfo.os.minor = parseInt(self.boxInfo.version.split('.')[2].split('-')[0]);
			
		} else { 
			self.boxInfo.os.major = null;
			self.boxInfo.os.minor = null;
		}
	  } else {
		self.boxInfo = { fritz: false };
		var error = 'BoxInfo element could not be parsed';
	  }
	} catch(err) {
	  self.boxInfo = { fritz: false };
	  var error = err;
	}	
	cb(error||null, self.boxInfo);  
	  
  });
};

Fbox.prototype.closeSession = function(SID, cb) {
  var self = this;
  requestValueAction (this._box.host, '/login_sid.lua?logout=logout&sid=' + SID, function (error, info) {

	if(error)
	  return cb(error, null);
	try {
	  if (info['SessionInfo']){
		self.SID = info['SessionInfo']['SID'].toString();
		  if (self.SID == '0000000000000000') {
			//self.SID = null;
			cb(error, info);
		  } else {
			var error = 'logout was unsuccessful';
			cb(error, info);
		  }
	  } else {
		var error = 'BoxInfo element could not be parsed';
		cb(error, null);
	  }
	} catch(error) {
	  cb(error, null);
	}
		
  });
};

function calculateResponse(Challenge, Password) {
  var Response = Challenge + '-' + Password;
  Response = iconvlite.encode(Response, 'ucs2');
  var md5 = crypto.createHash('md5');
  md5.update(Response, 'utf8');
  Response = Challenge + '-' + md5.digest('hex');
  return Response;
}

Fbox.prototype.createSession = function(resp, cb) {
  var self = this;
  if (resp == null)
	path = '/login_sid.lua';
  else
	path = '/login_sid.lua?username=' + this._box.user + '&response=' + resp;

  requestValueAction (this._box.host, path, function (error, info) {

	if(error)
	  return cb(error, { account: false });
	try {
	  if (info['SessionInfo']){
		self.SID = info['SessionInfo']['SID'].toString();
		  if (self.SID == '0000000000000000') {
			//self.SID = null;
			if (resp == null) {
			  var challenge = info['SessionInfo']['Challenge'].toString();
			  var response = calculateResponse(challenge, self._box.password);
			  self.createSession(response, cb);
			} else {
			  var error = 'account invalid';
			  cb(error, null);
			}
		  } else {
			cb(error, info);
		  }
	  } else {
		var error = 'BoxInfo element could not be parsed';
		cb(error, self.SID);
	  }
	} catch(error) {
	  cb(error, self.SID);
	}
		
  });
};

// home_auto_query

Fbox.prototype.getAHADevicesNET = function(cb) {
  var self = this;
  requestValueAction (this._box.host, '/net/home_auto_query.lua?sid=' + this.SID + '&command=AllOutletStates&xhr=1', function (error, info) {

	if(error)
	  return cb(error, null);

    if (info.Outlet_count){
	  for (var count = 0; count < parseInt(info.Outlet_count); count++) {
		if (self.ahaDeviceIDs.indexOf(info['DeviceID_' + parseInt(count + 1)].toString()) == -1) { // do not add if deviceID already exists
	      self.ahaDevices.push({ ID: info['DeviceID_' + parseInt(count + 1)], multiMeterTimer: null, outletTimer: null, multiMeterEnergyTimer: null, socketTimer: null });
		  self.ahaDeviceIDs.push(info['DeviceID_' + parseInt(count + 1)])
		}
	  }
	  cb(error, self.ahaDevices);
	} else {
	  cb('invalid response -> Outlet_count is missing', null);
	}		
  });
};

Fbox.prototype.getAHAMultiMeterState = function(MultiMeterID, cb) {
  var self = this;
  requestValueAction (this._box.host, '/net/home_auto_query.lua?sid=' + this.SID + '&command=MultiMeterState&id=' + MultiMeterID + '&xhr=1', function (error, info) {

	if(error)
	  return cb(error, null);
	  
    if (info.MM_Value_Power){
	  cb(null, info);
	} else {
	  cb('invalid response -> MM_Value_Power is missing', null);
	}		
  });
};

Fbox.prototype.switchOnOff = function(MultiMeterID, ValueToSet, cb) {
  var self = this;
  requestValueAction (this._box.host, '/net/home_auto_query.lua', 'sid=' + this.SID + '&command=SwitchOnOff&id=' + MultiMeterID + '&value_to_set=' + ValueToSet + '&xhr=1', function (error, info) {

	if(error)
	  return cb(error, null);
	  
    if (info){
	  cb(error, info);
	} else {
	  cb('invalid response -> MM_Value_Power is missing', null);
	}		
  });
};

Fbox.prototype.getSwitchStateNET = function(MultiMeterID, ValueToSet, cb) {
  var self = this;
  requestValueAction (this._box.host, '/net/home_auto_query.lua?sid=' + this.SID + '&command=SwitchOnOff&id=' + MultiMeterID + '&value_to_set=' + ValueToSet + '&xhr=1', function (error, info) {

	if(error)
	  return cb(error, null);
	  
    if (info){
	  cb(error, info);
	} else {
	  cb('invalid response -> MM_Value_Power is missing', null);
	}		
  });
};

// aha webservice

Fbox.prototype.getSwitchName = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=getswitchname&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}		
  });
};

Fbox.prototype.getSwitchEnergy = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=getswitchenergy&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

Fbox.prototype.getSwitchPower = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=getswitchpower&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

Fbox.prototype.getSwitchPresent = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=getswitchpresent&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

Fbox.prototype.getSwitchState = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=getswitchstate&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

Fbox.prototype.setSwitchON = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=setswitchon&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

Fbox.prototype.setSwitchOFF = function(ain, cb) {
  var self = this;
  requestValueAction (this._box.host, '/webservices/homeautoswitch.lua?sid=' + this.SID + '&switchcmd=setswitchoff&ain=' + ain, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  cb(null, resp.replace("\n","").replace("\r",""));
	}	
  });
};

//getAHADevices -> workaround till webservice supports listing of devices with ain
Fbox.prototype.getAHADevices = function(cb) {
  var self = this;
  
  requestValueAction (this._box.host, '/net/home_auto_overview.lua?sid=' + this.SID, function (error, resp) {
	if(error)
	  return cb(error, null);
	  
    if (resp == "inval" ){
	  cb('invalid response', resp);
	} else {
	  $ = cheerio.load(resp);
	  $('#tHAdevices .c3').each(function(index) {
	    if(index >= 1) { //skipp th (headline)
		  if (self.ahaDeviceIDs.indexOf($(this).text()) == -1) { // do not add if deviceID already exists
		  //console.log($(this).text());
	        self.ahaDevices.push({ ID: $(this).text(), multiMeterTimer: null, outletTimer: null, multiMeterEnergyTimer: null, socketTimer: null });
		    self.ahaDeviceIDs.push($(this).text())
		  }
		}
	  });
	  cb(null, self.ahaDevices);
	}	
  });
};

// helper

function requestValueAction(host, path, postData, cb) {

  if (typeof postData == "function") {
    cb = postData;
	var url = {
	  host: host,
	  path: path,
	  method: 'GET' //default
    };
  } else {
    var url = {
	  host: host,
	  path: path,
	  method: 'POST',
	  headers: {  
	    'Content-Type': 'application/x-www-form-urlencoded',  
	    'Content-Length': postData.length  
	  } 
    };
  }

  var req = http.request(url, function(response) {
	var data = '';
	response.on('data', function (chunk) {
	  data += chunk;
	});
	
	response.on('end', function () {
      switch(response.statusCode) {
        case 400:
		  cb(response.statusCode, null);
	      break;
        case 403:
		  cb('invalid SID', null);
	      break;
        case 500:
		  cb(response.statusCode, null);
	      break;
        case 200:
		  if (data.indexOf('login.lua') > -1) { // SID is not valid
			  cb('invalid SID', null);
		  } else {
		    try {
			  //console.log (response.headers['content-type']);
			  if (response.headers['content-type'].indexOf('xml') > -1) { // xml content -> xml2json
			    var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
			    parser.parseString(data, function (error, result) {
				  cb(null, result);
			    });
			  } else if (response.headers['content-type'].indexOf('json') > -1) { // json content
				  cb (null, JSON.parse(data));
			  } else { // other content -> return raw format
			    cb (null, data);
			  }	
		    } catch (error) {
			  cb(error, null);
		    }
		  }
		  break
        default:
		  cb(response.statusCode, null);
	  }
	});
	
  });

  req.setTimeout(10000, function() {
	console.log('request timedout out after 10 seconds, it seems that the requested host is not available');
	req.abort();
  });

  req.on('error', function(error) { // connection error -> host unreachable
	//console.log('ERROR:	requestValueAction	connection to host ' + url.host + ' failed: ' + error.message);
	cb(error.message, null); 
  });
  
  if (typeof postData != "function")
    req.write(postData);
  req.end();
};

